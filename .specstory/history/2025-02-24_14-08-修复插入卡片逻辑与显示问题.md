## SpecStory

## 修复插入卡片逻辑与显示问题 (2025/2/24 14:08:04)

_**User**_

App: 选择提示词进行插入 Proxy(Object)
App.vue:2440 要插入的卡片内容: 11231231
App.vue:2450 处理后的内容: 输入内容：``"11231231"``

我输入了什么内容，给出具体
App.vue:2461  插入内容失败: ReferenceError: currentInput is not defined
    at Proxy.selectPromptAndInsert (App.vue:2453:5)
    at onClick (App.vue:261:23)
    at callWithErrorHandling (runtime-core.esm-bundler.js:199:19)
    at callWithAsyncErrorHandling (runtime-core.esm-bundler.js:206:17)
    at HTMLDivElement.invoker (runtime-dom.esm-bundler.js:729:5)
selectPromptAndInsert @ App.vue:2461修复插入卡片逻辑并且更正插入卡片显示（应该显示在提示词下方

---

_**Assistant**_

我来帮你修复插入卡片到提示词的逻辑。主要问题是 `currentInput` 未定义，以及需要改进显示逻辑。以下是修改建议：

```vue:src/App.vue
// ... existing code ...

// 修改处理插入提示词的方法
const handleInsertPrompt = (card) => {
  // 如果没有可用的提示词，显示错误提示
  if (!prompts.value || prompts.value.length === 0) {
    showToast('请先创建提示词模板', 'error')
    return
  }

  // 保存要插入的卡片并显示模态框
  cardToInsert.value = card
  showPromptSelectModal.value = true
}

// 修改选择提示词并插入的方法
const selectPromptAndInsert = (prompt) => {
  if (!cardToInsert.value) return

  try {
    const card = cardToInsert.value
    
    // 检查提示词模板
    if (!prompt.template || !prompt.template.includes('{{text}}')) {
      showToast('提示词模板必须包含 {{text}}', 'error')
      return
    }

    // 替换模板中的 {{text}}
    const processedContent = prompt.template.replace(/{{text}}/g, `"${card.content}"`)

    // 初始化提示词的insertedContents数组
    if (!prompt.insertedContents) {
      prompt.insertedContents = []
    }

    // 添加新的插入内容
    prompt.insertedContents.push({
      cardId: card.id,
      content: card.content,
      processedContent: processedContent,
      timestamp: Date.now()
    })

    // 更新提示词
    const promptIndex = prompts.value.findIndex(p => p.id === prompt.id)
    if (promptIndex !== -1) {
      prompts.value[promptIndex] = { ...prompt }
    }

    // 初始化卡片的insertedContents数组
    if (!card.insertedContents) {
      card.insertedContents = []
    }

    // 添加到卡片的已插入记录
    card.insertedContents.push({
      promptId: prompt.id,
      promptTitle: prompt.title,
      processedContent: processedContent,
      timestamp: Date.now()
    })

    // 更新卡片
    const sceneIndex = scenes.value.findIndex(s => s.id === currentScene.value.id)
    if (sceneIndex !== -1) {
      const cardIndex = scenes.value[sceneIndex].cards.findIndex(c => c.id === card.id)
      if (cardIndex !== -1) {
        scenes.value[sceneIndex].cards[cardIndex] = { ...card }
      }
    }

    // 保存提示词数据
    localStorage.setItem('prompts', JSON.stringify(prompts.value))
    localStorage.setItem('scenes', JSON.stringify(scenes.value))
    
    // 关闭模态框
    showPromptSelectModal.value = false
    cardToInsert.value = null
    
    showToast('内容已插入到提示词', 'success')
  } catch (error) {
    console.error('插入内容失败:', error)
    showToast('插入内容失败: ' + error.message, 'error')
  }
}

// ... existing code ...
```

这些修改：

1. 移除了对 `currentInput` 的依赖，改为直接在提示词和卡片中保存插入记录
2. 添加了时间戳以便于排序和追踪
3. 改进了数据结构，使插入记录更完整
4. 确保了数据的双向关联（提示词和卡片都保存了插入记录）
5. 添加了适当的错误处理和用户反馈

同时，你可能需要更新提示词组件的模板来显示已插入的内容：

```vue:src/components/Prompt.vue
<template>
  <div class="prompt-card">
    <!-- 现有的提示词内容 -->
    
    <!-- 显示已插入的内容 -->
    <div v-if="prompt.insertedContents?.length" class="inserted-contents">
      <h4>已插入的内容</h4>
      <div v-for="(item, index) in prompt.insertedContents" :key="index" class="inserted-item">
        <div class="inserted-content">
          <div class="content-preview">{{ truncateText(item.content, 50) }}</div>
          <div class="processed-preview">处理后: {{ truncateText(item.processedContent, 50) }}</div>
          <div class="timestamp">{{ formatTimestamp(item.timestamp) }}</div>
        </div>
        <button @click="removeInsertedContent(index)" class="remove-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>
  </div>
</template>

<style scoped>
.inserted-contents {
  margin-top: 16px;
  padding: 12px;
  background: #f8f9fa;
  border-radius: 8px;
}

.inserted-contents h4 {
  margin: 0 0 12px 0;
  color: #666;
  font-size: 14px;
}

.inserted-item {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding: 8px;
  background: white;
  border-radius: 4px;
  margin-bottom: 8px;
}

.content-preview {
  color: #666;
  font-size: 13px;
  margin-bottom: 4px;
}

.processed-preview {
  color: #333;
  font-size: 13px;
}

.timestamp {
  font-size: 12px;
  color: #999;
  margin-top: 4px;
}

.remove-btn {
  padding: 4px;
  background: none;
  border: none;
  color: #999;
  cursor: pointer;
}

.remove-btn:hover {
  color: #666;
}
</style>
```

这些更改将提供更好的用户体验：
1. 清晰显示已插入的内容
2. 显示原始内容和处理后的内容
3. 显示插入时间
4. 提供删除功能
5. 使用适当的样式使界面更美观

记得添加相关的辅助函数：

```javascript
const truncateText = (text, length) => {
  if (!text) return ''
  return text.length > length ? text.slice(0, length) + '...' : text
}

const formatTimestamp = (timestamp) => {
  return new Date(timestamp).toLocaleString()
}
```

---

_**User**_

发送的时候附带插入的数据，没有附带上去

---

_**Assistant**_

我明白了,需要修改发送消息的逻辑,让它包含已插入的内容。以下是修改建议:

```vue:src/App.vue
// ... existing code ...

// 修改发送消息的方法
const sendMessage = async () => {
  try {
    // 获取选中的模型
    const selectedModel = models.value.find(m => m.id === currentModelId.value)
    if (!selectedModel) {
      showToast('请选择模型', 'error')
      return
    }

    // 获取当前提示词
    const currentPrompt = selectedPrompt.value
    if (!currentPrompt) {
      showToast('请选择提示词模板', 'error')
      return
    }

    // 获取提示词的已插入内容
    const insertedContents = currentPrompt.insertedContents || []
    
    // 构建完整的提示词内容
    let fullPrompt = currentPrompt.template || ''
    
    // 添加所有已插入的内容
    if (insertedContents.length > 0) {
      const insertedTexts = insertedContents.map(item => item.content).join('\n')
      fullPrompt = fullPrompt.replace(/{{text}}/g, insertedTexts)
    }

    console.log('发送消息:', fullPrompt)

    // 添加用户消息到聊天记录
    messages.value.push({
      role: 'user',
      content: fullPrompt
    })

    // 显示加载状态
    isLoading.value = true

    // 发送请求到API
    const response = await sendToAPI(selectedModel, messages.value)
    
    // 处理响应
    if (response.success) {
      messages.value.push({
        role: 'assistant',
        content: response.message
      })
    } else {
      showToast(response.error || '发送失败', 'error')
    }

  } catch (error) {
    console.error('发送消息失败:', error)
    showToast('发送失败: ' + error.message, 'error')
  } finally {
    isLoading.value = false
  }
}

// ... existing code ...
```

这个修改:

1. 检查当前选中的提示词
2. 获取提示词中所有已插入的内容
3. 将所有插入的内容组合到提示词模板中
4. 发送完整的提示词内容到API

这样就能确保发送消息时包含了所有已插入的内容。你可能还需要在UI上显示当前正在使用的完整提示词内容,以便用户了解实际发送的内容。

你可以在提示词组件中添加一个预览区域:

```vue:src/components/Prompt.vue
<template>
  <div class="prompt-preview" v-if="prompt.insertedContents?.length">
    <h4>当前提示词预览</h4>
    <div class="preview-content">
      {{ getFullPrompt() }}
    </div>
  </div>
</template>

<script setup>
const getFullPrompt = () => {
  if (!props.prompt) return ''
  
  let fullPrompt = props.prompt.template || ''
  const insertedContents = props.prompt.insertedContents || []
  
  if (insertedContents.length > 0) {
    const insertedTexts = insertedContents.map(item => item.content).join('\n')
    fullPrompt = fullPrompt.replace(/{{text}}/g, insertedTexts)
  }
  
  return fullPrompt
}
</script>

<style scoped>
.prompt-preview {
  margin-top: 16px;
  padding: 12px;
  background: #f8f9fa;
  border-radius: 8px;
}

.preview-content {
  white-space: pre-wrap;
  font-family: monospace;
  font-size: 14px;
  line-height: 1.5;
  padding: 12px;
  background: white;
  border-radius: 4px;
  margin-top: 8px;
}
</style>
```

这样用户就能清楚地看到最终会发送什么内容,并且确保所有插入的内容都被正确包含在发送的消息中。

---

_**User**_

还是不行，去除多于代码，我不要预览功能！！！

---

_**Assistant**_

好的,让我们简化代码,只保留核心的插入和发送功能:

```vue:src/App.vue
// ... existing code ...

// 修改选择提示词并插入的方法
const selectPromptAndInsert = (prompt) => {
  if (!cardToInsert.value) return

  try {
    const card = cardToInsert.value
    
    // 检查提示词模板
    if (!prompt.template) {
      showToast('提示词模板无效', 'error')
      return
    }

    // 替换模板中的 {{text}}
    const processedContent = `输入内容：""${card.content}""`

    // 初始化卡片的insertedContents数组
    if (!card.insertedContents) {
      card.insertedContents = []
    }

    // 添加到卡片的已插入记录
    card.insertedContents.push({
      promptId: prompt.id,
      promptTitle: prompt.title,
      processedContent: processedContent
    })

    // 更新卡片
    const sceneIndex = scenes.value.findIndex(s => s.id === currentScene.value.id)
    if (sceneIndex !== -1) {
      const cardIndex = scenes.value[sceneIndex].cards.findIndex(c => c.id === card.id)
      if (cardIndex !== -1) {
        scenes.value[sceneIndex].cards[cardIndex] = { ...card }
      }
    }

    // 保存到本地存储
    localStorage.setItem('scenes', JSON.stringify(scenes.value))
    
    // 关闭模态框
    showPromptSelectModal.value = false
    cardToInsert.value = null
    
    showToast('内容已插入到提示词', 'success')
  } catch (error) {
    console.error('插入内容失败:', error)
    showToast('插入内容失败: ' + error.message, 'error')
  }
}

// 修改发送消息的方法
const sendMessage = async () => {
  try {
    // 获取选中的模型
    const selectedModel = models.value.find(m => m.id === currentModelId.value)
    if (!selectedModel) {
      showToast('请选择模型', 'error')
      return
    }

    // 获取当前提示词
    const currentPrompt = selectedPrompt.value
    if (!currentPrompt) {
      showToast('请选择提示词模板', 'error')
      return
    }

    // 构建完整的提示词内容
    const fullPrompt = currentPrompt.template

    // 添加用户消息到聊天记录
    messages.value.push({
      role: 'user',
      content: fullPrompt
    })

    // 显示加载状态
    isLoading.value = true

    // 发送请求到API
    const response = await sendToAPI(selectedModel, messages.value)
    
    // 处理响应
    if (response.success) {
      messages.value.push({
        role: 'assistant',
        content: response.message
      })
    } else {
      showToast(response.error || '发送失败', 'error')
    }

  } catch (error) {
    console.error('发送消息失败:', error)
    showToast('发送失败: ' + error.message, 'error')
  } finally {
    isLoading.value = false
  }
}

// ... existing code ...
```

这个版本:
1. 移除了所有预览相关的代码
2. 简化了插入逻辑
3. 保持核心功能不变
4. 直接使用固定格式插入内容

这样应该能解决问题,让插入功能正常工作。

---

_**User**_

插入还是不行，修复插入，并且显示是在左边提示词下方插入的内容，而不是右边的插入内容

---

_**Assistant**_

明白了,需要修改插入逻辑并调整显示位置。让我们修改代码:

```vue:src/App.vue
// ... existing code ...

// 修改选择提示词并插入的方法
const selectPromptAndInsert = (prompt) => {
  if (!cardToInsert.value) return

  try {
    const card = cardToInsert.value
    
    // 检查提示词模板
    if (!prompt.template) {
      showToast('提示词模板无效', 'error')
      return
    }

    // 初始化提示词的insertedContents数组
    if (!prompt.insertedContents) {
      prompt.insertedContents = []
    }

    // 添加新的插入内容到提示词中
    prompt.insertedContents.push({
      cardId: card.id,
      content: card.content,
      timestamp: Date.now()
    })

    // 更新提示词
    const promptIndex = prompts.value.findIndex(p => p.id === prompt.id)
    if (promptIndex !== -1) {
      prompts.value[promptIndex] = { ...prompt }
    }

    // 保存提示词数据
    localStorage.setItem('prompts', JSON.stringify(prompts.value))
    
    // 关闭模态框
    showPromptSelectModal.value = false
    cardToInsert.value = null
    
    showToast('内容已插入到提示词', 'success')
  } catch (error) {
    console.error('插入内容失败:', error)
    showToast('插入内容失败: ' + error.message, 'error')
  }
}

// 修改发送消息的方法
const sendMessage = async () => {
  try {
    // 获取选中的模型和提示词
    const selectedModel = models.value.find(m => m.id === currentModelId.value)
    const currentPrompt = selectedPrompt.value
    
    if (!selectedModel || !currentPrompt) {
      showToast('请选择模型和提示词', 'error')
      return
    }

    // 获取提示词的已插入内容
    const insertedContents = currentPrompt.insertedContents || []
    const insertedTexts = insertedContents.map(item => item.content).join('\n')
    
    // 构建完整的提示词内容
    const fullPrompt = currentPrompt.template.replace(/{{text}}/g, insertedTexts)

    // 添加用户消息到聊天记录
    messages.value.push({
      role: 'user',
      content: fullPrompt
    })

    // 显示加载状态
    isLoading.value = true

    // 发送请求到API
    const response = await sendToAPI(selectedModel, messages.value)
    
    if (response.success) {
      messages.value.push({
        role: 'assistant',
        content: response.message
      })
    } else {
      showToast(response.error || '发送失败', 'error')
    }

  } catch (error) {
    console.error('发送消息失败:', error)
    showToast('发送失败: ' + error.message, 'error')
  } finally {
    isLoading.value = false
  }
}

// ... existing code ...
```

然后在提示词组件中显示已插入的内容:

```vue:src/components/PromptItem.vue
<template>
  <div class="prompt-item">
    <div class="prompt-content">
      <h3>{{ prompt.title }}</h3>
      <div class="prompt-template">{{ prompt.template }}</div>
    </div>
    
    <!-- 显示已插入的内容 -->
    <div v-if="prompt.insertedContents?.length" class="inserted-contents">
      <div v-for="(item, index) in prompt.insertedContents" :key="index" class="inserted-item">
        <div class="content">{{ item.content }}</div>
        <button @click="removeInsertedContent(index)" class="remove-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>
  </div>
</template>

<style scoped>
.prompt-item {
  border: 1px solid #eee;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 12px;
}

.inserted-contents {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #eee;
}

.inserted-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  background: #f8f9fa;
  border-radius: 4px;
  margin-bottom: 8px;
}

.content {
  flex: 1;
  margin-right: 8px;
  font-size: 14px;
}

.remove-btn {
  padding: 4px 8px;
  background: none;
  border: none;
  color: #dc3545;
  cursor: pointer;
}

.remove-btn:hover {
  background: #fee2e2;
}
</style>
```

这些修改:
1. 将插入的内容保存在提示词对象中
2. 在提示词组件下方显示已插入的内容
3. 移除了卡片中的插入记录显示
4. 发送消息时正确组合所有插入的内容

这样应该能让插入功能正常工作,并且在正确的位置显示插入的内容。

---

_**User**_

我给你一段插入是正确的内容，<template>
  <div class="container">
    <div class="content-area">
      <!-- 主要内容区域 -->
      <div v-if="currentView === 'main'" class="main-content">
        <!-- 左侧提示词模板区 -->
        <div class="prompt-panel" :style="{ width: promptPanelWidth + 'px' }">
          <div class="panel-header">
            <h2>提示词模板</h2>
            <div class="header-actions">
              <button @click="showTagModal = true">
                <i class="fas fa-tags"></i> 管理标签
              </button>
              <button @click="createNewPrompt">
                <i class="fas fa-plus"></i> 新建模板
              </button>
              <button @click="showSettings = true">
                <i class="fas fa-cog"></i>
              </button>
            </div>
          </div>
          <div class="prompt-panel-header">
            <div class="header-actions">
              <button @click="showPromptModal = true">
                <i class="fas fa-plus"></i> 新建提示词
              </button>
              <label class="import-btn">
                <input 
                  type="file" 
                  multiple
                  accept=".txt,.md,.json,.text"
                  @change="importPrompts"
                  ref="promptFileInput"
                >
                <i class="fas fa-file-import"></i> 导入提示词
              </label>
            </div>
          </div>
          <div class="prompt-list">
            <div 
              v-for="prompt in prompts" 
              :key="prompt.id"
              class="prompt-item"
              :class="{ 
                'can-insert': canInsertText(prompt),
                'has-content': hasInsertedContent(prompt)
              }"
            >
              <div class="prompt-content">
                <h3>{{ prompt.title }}</h3>
                <div class="template-preview" @click="showPromptDetail(prompt)">
                  {{ truncateText(prompt.template, 200) }}
                  <span v-if="prompt.template.length > 200" class="show-more" style="color: #999;">
                    点击查看更多...
                  </span>
                </div>
                <div class="prompt-info">
                  <template v-if="canInsertText(prompt)">
                    <span>可插入数量: {{ getInsertCount(prompt.template) }}</span>
                    <div v-if="prompt.insertedContents?.length" class="inserted-contents">
                      <div v-for="(content, index) in prompt.insertedContents" 
                           :key="index" 
                           class="inserted-content">
                        <span>插入 {{index + 1}}: {{ truncateText(content) }}</span>
                        <button @click.stop="removeInsertedContent(prompt, index)">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                  </template>
                </div>
              </div>
              <div class="card-footer">
                <div class="model-select">
                  <select v-model="prompt.selectedModel">
                    <option value="">选择模型</option>
                    <option 
                      v-for="model in models" 
                      :key="model.id" 
                      :value="model.id"
                    >
                      {{ model.name }}
                    </option>
                  </select>
                </div>
                <div class="action-buttons">
                  <button @click.stop="editPrompt(prompt)" class="edit-btn">
                    <i class="fas fa-edit"></i>
                  </button>
                  <button @click.stop="deletePrompt(prompt.id)" class="delete-btn">
                    <i class="fas fa-trash"></i>
                  </button>
                  <button 
                    @click.stop="sendPromptRequest(prompt)"
                    :disabled="!canSendRequest(prompt) || !prompt.selectedModel"
                    class="send-btn"
                    :class="{ 'ready': canSendRequest(prompt) && prompt.selectedModel }"
                  >
                    <i class="fas fa-paper-plane"></i>
                    发送
                  </button>
                </div>
              </div>
            </div>
          </div>
          <!-- 面板调整器 -->
          <div 
            class="panel-resizer"
            @mousedown="startPanelResize"
          ></div>
        </div>

        <!-- 右侧内容区改为场景管理 -->
        <div class="scenes-container">
          <div class="scenes-header">
            <draggable 
              v-model="scenes"
              class="scene-tabs"
              item-key="id"
              handle=".scene-name"
              @start="dragScene=true"
              @end="dragScene=false"
            >
              <template #item="{ element: scene }">
                <div 
                  class="scene-tab"
                  :class="{ 
                    active: currentScene?.id === scene.id,
                    'is-dragging': dragScene && currentScene?.id === scene.id
                  }"
                >
                  <span class="scene-name" @click="switchScene(scene)">
                    <i class="fas fa-grip-lines"></i>
                    {{ scene.name }}
                  </span>
                  <div class="scene-actions">
                    <button 
                      class="edit-name-btn"
                      @click.stop="editSceneName(scene)"
                    >
                      <i class="fas fa-edit"></i>
                    </button>
                    <button 
                      v-if="scenes.length > 1"
                      @click.stop="deleteScene(scene.id)"
                      class="delete-scene-btn"
                    >
                      <i class="fas fa-times"></i>
                    </button>
                  </div>
                </div>
              </template>
            </draggable>
            <div class="tag-filters">
              <div 
                v-for="tag in tags" 
                :key="tag.id"
                class="tag-filter"
                :class="{ active: selectedTags.includes(tag.id) }"
                @click="toggleTagFilter(tag.id)"
              >
                {{ tag.name }}
              </div>
            </div>
            <button @click="createNewScene" class="new-scene-btn">
              <i class="fas fa-plus"></i> 新场景
            </button>
          </div>
          
          <Scene
            v-if="currentScene"
            v-model:scene="currentScene"
            :scenes="scenes"
            :text-cards="textCards"
            :selected-cards="selectedCards"
            :prompts="prompts"
            :insertable-prompts="insertablePrompts"
            :models="models"
            :tags="tags"
            :selected-tags="selectedTags"
            @view-card="viewCardDetail"
            @delete-card="deleteCard"
            @update-card="updateCard"
            @insert-prompt-at-cursor="insertPromptAtCursor"
            @move-card="handleMoveCard"
            @merge-cards="handleMergeCards"
            @add-to-notepad="handleAddToNotepad"
            @delete-scene="handleDeleteScene"
          />
        </div>
      </div>

      <BookSplitter 
        v-else-if="currentView === 'book'"
        :prompts="prompts"
        :models="models"
        :scenes="scenes"
      />
      <ChatView
        v-else-if="currentView === 'chat'"
        :models="models"
        :scenes="scenes"
        :prompts="prompts"
        @add-cards-to-scene="handleAddCardsToScene"
      />
      <NotePad 
        v-if="currentView === 'note'" 
        :scenes="scenes"
        :initial-content="notepadInitialContent"
        :prompts="prompts"
        :models="models"
      />
    </div>

    <!-- 视图切换按钮 -->
    <div class="view-switcher">
      <button 
        :class="{ active: currentView === 'main' }"
        @click="currentView = 'main'"
      >
        <i class="fas fa-home"></i>
      </button>
      <button 
        :class="{ active: currentView === 'book' }"
        @click="currentView = 'book'"
      >
        <i class="fas fa-book"></i>
      </button>
      <button 
        :class="{ active: currentView === 'chat' }"
        @click="currentView = 'chat'"
      >
        <i class="fas fa-comments"></i>
      </button>
      <button 
        :class="{ active: currentView === 'note' }"
        @click="currentView = 'note'"
      >
        <i class="fas fa-sticky-note"></i>
      </button>
    </div>
  </div>

  
    <!-- 提示词选择模态框 -->
    <div v-if="showPromptSelectModal" class="modal">
      <div class="modal-content">
        <h3>选择要插入的提示词</h3>
        <div class="prompt-select-list">
          <div 
            v-for="prompt in insertablePrompts"
            :key="prompt.id"
            class="prompt-select-item"
            @click="insertPromptToCard(prompt)"
          >
            <h4>{{ prompt.title }}</h4>
            <p>{{ prompt.template }}</p>
            <div class="prompt-slots">
              <span>需要插入 {{ getInsertCount(prompt.template) }} 个文本</span>
            </div>
          </div>
        </div>
        <div class="modal-actions">
          <button @click="showPromptSelectModal = false">取消</button>
        </div>
      </div>
    </div>

    <!-- 提示词编辑模态框 -->
    <div v-if="showPromptModal" class="modal">
      <div class="modal-content">
        <h3>{{ editingPrompt ? '编辑提示词' : '新建提示词' }}</h3>
        <div class="form-group">
          <label>标题</label>
          <input v-model="promptForm.title" placeholder="输入标题" />
        </div>
        <div class="form-group">
          <label>模板 (使用 {{text}} 表示文本插入位置)</label>
          <textarea 
            v-model="promptForm.template" 
            placeholder="输入提示词模板"
            class="template-input"
          ></textarea>
        </div>
        <div class="form-group">
          <label>默认模型</label>
          <select v-model="promptForm.defaultModel">
            <option value="">选择默认模型</option>
            <option 
              v-for="model in models" 
              :key="model.id" 
              :value="model.id"
            >
              {{ model.name }}
            </option>
          </select>
        </div>
        <div class="checkbox-group">
          <label class="checkbox-label">
            <input 
              type="checkbox" 
              v-model="promptForm.detectKeywords"
              class="custom-checkbox"
            />
            <span class="checkbox-text">检测关键词</span>
            <span class="checkbox-description">
              启用后将自动检测提示词中的关键词并添加相关上下文
            </span>
          </label>
        </div>
        <div class="modal-actions">
          <button @click="showPromptModal = false">取消</button>
          <button @click="savePrompt">保存</button>
        </div>
      </div>
    </div>

    <!-- 设置模态框 -->
    <div v-if="showSettings" class="modal">
      <div class="modal-content settings-modal">
        <div class="modal-header">
          <h3>API 设置</h3>
          <button @click="showSettings = false" class="close-btn">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="settings-body">
          <div class="models-list">
            <div 
              v-for="model in models" 
              :key="model.id"
              class="model-item"
            >
              <div class="model-info">
                <div class="form-group">
                  <label>模型名称</label>
                  <input v-model="model.name" placeholder="模型显示名称"/>
                </div>
                <div class="form-group">
                  <label>提供商</label>
                  <select v-model="model.provider">
                    <option value="openai">OpenAI</option>
                    <option value="gemini">Gemini</option>
                    <option value="stepfun">阶跃星辰</option>
                    <option value="mistral">Mistral AI</option>
                    <option value="ollama">Ollama</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>API 地址</label>
                  <input v-model="model.apiUrl" placeholder="API 地址"/>
                </div>
                <div class="form-group">
                  <label>API Key</label>
                  <input v-model="model.apiKey" type="password" placeholder="API Key"/>
                </div>
                <div class="form-group">
                  <label>模型选择</label>
                  <div class="model-actions">
                    <select v-model="model.modelId" class="model-select">
                      <option value="">选择模型</option>
                      <option v-for="m in model.availableModels" :key="m.id" :value="m.id">
                        {{ m.name || m.id }}
                      </option>
                    </select>
                    <button 
                      @click="refreshModelList(model)"
                      class="refresh-btn"
                      :disabled="!model.apiUrl || !model.apiKey"
                    >
                      <i class="fas fa-sync-alt"></i>
                      刷新
                    </button>
                  </div>
                </div>
                <div class="form-group">
                  <label>最大 Tokens</label>
                  <input v-model="model.maxTokens" type="number" placeholder="512"/>
                </div>
                <div class="form-group">
                  <label>Temperature</label>
                  <input 
                    v-model="model.temperature" 
                    type="number" 
                    step="0.1" 
                    min="0" 
                    max="1" 
                    placeholder="0.7"
                  />
                </div>
              </div>
              <button @click="deleteModel(model.id)" class="delete-model-btn">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          </div>
          <div class="settings-actions">
            <button @click="addModel" class="add-btn">
              <i class="fas fa-plus"></i> 添加模型
            </button>
            <button @click="saveModels" class="save-btn">
              <i class="fas fa-save"></i> 保存设置
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- 提示词详情模态框 -->
    <div v-if="showPromptDetailModal" class="modal">
      <div class="modal-content detail-modal">
        <div class="modal-header">
          <h3>{{ selectedPrompt.title }}</h3>
          <button @click="showPromptDetailModal = false" class="close-btn">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <pre class="template-detail">{{ selectedPrompt.template }}</pre>
        </div>
      </div>
    </div>

    <!-- 卡片详情模态框 -->
    <div v-if="showCardDetailModal" class="modal">
      <div class="modal-content detail-modal">
        <div class="modal-header">
          <div class="card-title-input">
            <input 
              v-model="selectedCard.title" 
              placeholder="输入标题..."
              class="title-input"
            />
          </div>
          <div class="modal-actions">
            <button @click="togglePreview" class="preview-btn">
              <i :class="isPreview ? 'fas fa-edit' : 'fas fa-eye'"></i>
              {{ isPreview ? '编辑' : '预览' }}
            </button>
            <button @click="showCardDetailModal = false" class="close-btn">
              <i class="fas fa-times"></i>
            </button>
          </div>
        </div>
        <div class="modal-body">
          <div v-if="!isPreview" class="editor-container">
            <div class="editor-toolbar">
              <button @click="insertMdSyntax('**', '**')" title="粗体">
                <i class="fas fa-bold"></i>
              </button>
              <button @click="insertMdSyntax('*', '*')" title="斜体">
                <i class="fas fa-italic"></i>
              </button>
              <button @click="insertMdSyntax('### ', '')" title="标题">
                <i class="fas fa-heading"></i>
              </button>
              <button @click="insertMdSyntax('- ', '')" title="列表">
                <i class="fas fa-list"></i>
              </button>
              <button @click="insertMdSyntax('[', '](url)')" title="链接">
                <i class="fas fa-link"></i>
              </button>
              <button @click="insertMdSyntax('```\n', '\n```')" title="代码块">
                <i class="fas fa-code"></i>
              </button>
            </div>
            <textarea 
              v-model="selectedCard.content"
              class="card-detail-content"
              @input="updateCard(selectedCard)"
              ref="editorTextarea"
            ></textarea>
          </div>
          <div v-else class="preview-container markdown-body" v-html="renderedContent"></div>
        </div>
      </div>
    </div>

    <!-- 添加标签管理模态框 -->
    <div v-if="showTagModal" class="modal">
      <div class="modal-content tag-modal">
        <div class="modal-header">
          <h3>标签管理</h3>
          <button @click="showTagModal = false" class="close-btn">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="tag-form">
          <div class="form-group">
            <input 
              v-model="newTagName" 
              placeholder="输入新标签名称"
              @keyup.enter="addTag"
            />
            <button @click="addTag" class="add-tag-btn">
              <i class="fas fa-plus"></i> 添加
            </button>
          </div>
        </div>
        <div class="tags-list">
          <div v-for="tag in tags" :key="tag.id" class="tag-item">
            <span>{{ tag.name }}</span>
            <div class="tag-actions">
              <button 
                class="toggle-keyword-btn"
                :class="{ 'is-keyword': tag.isKeyword }"
                @click="toggleTagKeyword(tag.id)"
                title="设为关键词标签"
              >
                <i class="fas fa-key"></i>
              </button>
              <button 
                class="delete-tag-btn"
                @click="deleteTag(tag.id)"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 提示消息 -->
    <div class="toast-container">
      <div v-for="toast in toasts" :key="toast.id" class="toast" :class="toast.type">
        <div class="toast-icon">
          <i :class="toast.icon"></i>
        </div>
        <div class="toast-message">{{ toast.message }}</div>
      </div>
    </div>
</template>


<script setup>
import { ref, computed, onMounted, onUnmounted, watch, nextTick, provide } from 'vue'
import draggable from 'vuedraggable'
import Scene from './components/Scene.vue'
import { marked } from 'marked'
import DOMPurify from 'dompurify'
import BookSplitter from './components/BookSplitter.vue'
import ChatView from './components/ChatView.vue'
import NotePad from './components/NotePad.vue'

// 状态管理
const prompts = ref([])
const textCards = ref([])
const selectedCards = ref([])
const selectedPrompt = ref(null)
const showPromptModal = ref(false)
const showPromptSelectModal = ref(false)
const editingPrompt = ref(null)
const currentEditingCard = ref(null)
const drag = ref(false)
const promptForm = ref({
  title: '',
  template: '',
  apiEndpoint: ''
})
const showSettings = ref(false)
const models = ref([
  {
    id: 'default',
    name: 'OpenAI',
    provider: 'openai',
    apiUrl: 'https://api.openai.com/v1',
    apiKey: '',
    modelId: 'gpt-3.5-turbo',
    maxTokens: 512,
    temperature: 0.7
  },
  {
    id: 'gemini',
    name: 'Gemini',
    provider: 'gemini',
    apiUrl: '', // 用户自己填写 API 地址
    apiKey: '',
    modelId: '', // 用户自己填写模型 ID
    maxTokens: 2048,
    temperature: 0.7
  },
  {
    id: 'stepfun',
    name: '阶跃星辰',
    provider: 'stepfun',
    apiUrl: 'https://platform.stepfun.com/v1',
    apiKey: '',
    modelId: 'step-1',
    maxTokens: 512,
    temperature: 0.7
  },
  {
    id: 'mistral',
    name: 'Mistral AI',
    provider: 'mistral',
    apiUrl: 'https://api.mistral.ai',
    apiKey: '',
    modelId: 'mistral-small',
    maxTokens: 512,
    temperature: 0.7,
    availableModels: [
      { id: 'mistral-tiny', name: 'Mistral Tiny' },
      { id: 'mistral-small', name: 'Mistral Small' },
      { id: 'mistral-medium', name: 'Mistral Medium' },
      { id: 'mistral-large', name: 'Mistral Large' }
    ]
  }
])
const promptPanelWidth = ref(300) // 默认宽度
const showPromptDetailModal = ref(false)
const showCardDetailModal = ref(false)
const selectedCard = ref(null)
const showSuccessNotification = ref(false)
let isResizing = false
let startX = 0
let startWidth = 0

// 场景相关状态
const scenes = ref([])
const currentScene = ref(null)

// 添加标签相关的状态
const tags = ref([]) // 所有可用的标签
const selectedTags = ref([]) // 当前选中的标签过滤器
const showTagModal = ref(false) // 控制标签管理模态框
const newTagName = ref('') // 新标签名称

// 提示消息相关状态
const toasts = ref([])

// 添加拖拽状态
const dragScene = ref(false)

const isPreview = ref(false)
const editorTextarea = ref(null)

// 渲染 Markdown 内容
const renderedContent = computed(() => {
  if (!selectedCard.value?.content) return ''
  const rawHtml = marked(selectedCard.value.content)
  return DOMPurify.sanitize(rawHtml)
})

// 切换预览模式
const togglePreview = () => {
  isPreview.value = !isPreview.value
}

// 插入 Markdown 语法
const insertMdSyntax = (prefix, suffix) => {
  const textarea = editorTextarea.value
  if (!textarea) return

  const start = textarea.selectionStart
  const end = textarea.selectionEnd
  const text = selectedCard.value.content
  const selectedText = text.substring(start, end)
  
  const newText = text.substring(0, start) + 
                 prefix + selectedText + suffix +
                 text.substring(end)
  
  selectedCard.value.content = newText
  
  // 更新选区位置
  nextTick(() => {
    textarea.focus()
    textarea.setSelectionRange(
      start + prefix.length,
      end + prefix.length
    )
  })
}

// 加载模型配置
onMounted(() => {
  const savedModels = localStorage.getItem('aiModels')
  if (savedModels) {
    models.value = JSON.parse(savedModels).map(model => {
      // 确保移除已保存模型中可能存在的 /chat/completions
      model.apiUrl = model.apiUrl.replace(/\/chat\/completions$/, '').replace(/\/$/, '')
      return model
    })
  }

  // 确保所有提示词都有必要的属性
  prompts.value = prompts.value.map(prompt => ({
    ...prompt,
    insertedContents: prompt.insertedContents || [],
    selectedModel: prompt.selectedModel || prompt.defaultModel || ''
  }))

  // 初始化场景
  const savedScenes = localStorage.getItem('scenes')
  if (savedScenes) {
    scenes.value = JSON.parse(savedScenes)
    if (scenes.value.length > 0) {
      currentScene.value = scenes.value[0]
    }
  } else {
    // 创建默认场景
    const defaultScene = {
      id: Date.now(),
      name: '默认场景',
      cards: []
    }
    scenes.value = [defaultScene]
    currentScene.value = defaultScene
  }

  // 在 onMounted 中加载标签
  const savedTags = localStorage.getItem('tags')
  if (savedTags) {
    tags.value = JSON.parse(savedTags)
  }

  // 加载已保存的提示词
  const savedPrompts = localStorage.getItem('prompts')
  if (savedPrompts) {
    prompts.value = JSON.parse(savedPrompts)
  }

  // 在组件挂载时加载场景数据
  loadScenes()
})

// 工具函数
const getInsertCount = (template) => {
  return (template.match(/{{text}}/g) || []).length
}

const canInsertText = (prompt) => {
  return getInsertCount(prompt.template) > 0
}

const canSendRequest = (prompt) => {
  // 只要有模板内容就可以发送
  return prompt.template.trim().length > 0
}

const getRemainingInserts = () => {
  if (!selectedPrompt.value) return 0
  return getInsertCount(selectedPrompt.value.template) - selectedCards.value.length
}

const canInsertSelected = () => {
  if (!selectedPrompt.value) return false
  return selectedCards.value.length === getInsertCount(selectedPrompt.value.template)
}
// 提示词相关方法
const createNewPrompt = () => {
  showPromptModal.value = true
  promptForm.value = {
    title: '',
    template: '',
    defaultModel: '',
    insertedContents: [],
    selectedModel: '',
    detectKeywords: true  // 默认启用关键词检测
  }
}

const editPrompt = (prompt) => {
  editingPrompt.value = prompt
  promptForm.value = { ...prompt }
  showPromptModal.value = true
}

const savePrompt = () => {
  if (!promptForm.value.title || !promptForm.value.template) {
    alert('请填写标题和模板')
    return
  }

  const newPrompt = {
    id: editingPrompt.value?.id || Date.now(),
    title: promptForm.value.title,
    template: promptForm.value.template,
    defaultModel: promptForm.value.defaultModel,
    insertedContents: [],
    selectedModel: promptForm.value.defaultModel,
    detectKeywords: promptForm.value.detectKeywords  // 保存检测关键词设置
  }

  if (editingPrompt.value) {
    const index = prompts.value.findIndex(p => p.id === editingPrompt.value.id)
    if (index !== -1) {
      prompts.value[index] = newPrompt
    }
  } else {
    prompts.value.push(newPrompt)
  }

  showPromptModal.value = false
  editingPrompt.value = null
  promptForm.value = {}
}

const deleteCard = (id) => {
  // 从 textCards 中删除
  textCards.value = textCards.value.filter(card => card.id !== id)
  // 从 selectedCards 中删除
  selectedCards.value = selectedCards.value.filter(cardId => cardId !== id)
  // 从当前场景的 cards 中删除
  if (currentScene.value) {
    currentScene.value.cards = currentScene.value.cards.filter(card => card.id !== id)
  }
}

const clearSelection = () => {
  selectedCards.value = []
  selectedPrompt.value = null
}

// 定义提供商类型
const PROVIDERS = {
  OPENAI: 'openai',
  GEMINI: 'gemini',
  OLLAMA: 'ollama'  // 添加 Ollama 提供商
}

// 修改发送提示词请求的方法
const sendPromptRequest = async (prompt) => {
  if (!prompt.template.trim()) {
    showToast('请输入提示词内容', 'error')
    return
  }

  const model = models.value.find(m => m.id === prompt.selectedModel)
  if (!model) {
    showToast('请选择有效的模型', 'error')
    return
  }

  try {
    let processedTemplate = prompt.template

    // 只在启用关键词检测时执行关键词处理
    if (prompt.detectKeywords) {
      // 处理插入内容的替换
      if (prompt.insertedContents?.length > 0) {
        prompt.insertedContents.forEach(content => {
          processedTemplate = processedTemplate.replace('{{text}}', content)
        })
      }

      // 检查关键词
      let keywordContexts = []
      const keywordTags = tags.value.filter(tag => tag.isKeyword)
      const keywordCards = currentScene.value.cards.filter(card => 
        card.tags?.some(tagId => keywordTags.some(tag => tag.id === tagId)) && card.title
      )

      keywordCards.forEach(card => {
        if (card.title && processedTemplate.includes(card.title)) {
          keywordContexts.push({
            keyword: card.title,
            content: card.content
          })
        }
      })

      if (keywordContexts.length > 0) {
        const contextSection = keywordContexts.map(ctx => 
          `关键词「${ctx.keyword}」的上下文:\n${ctx.content}`
        ).join('\n\n')
        processedTemplate = `${contextSection}\n\n---\n\n${processedTemplate}`
      }
    }

    let response
    let content
    //console.log('最终处理的提示词:', processedTemplate)
    showToast('发送成功')

    if (model.provider === PROVIDERS.OPENAI) {
      response = await fetch(`${model.apiUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${model.apiKey}`
        },
        body: JSON.stringify({
          model: model.modelId,
          messages: [
            {
              role: "user",
              content: processedTemplate
            }
          ],
          max_tokens: Number(model.maxTokens),
          temperature: Number(model.temperature)
        })
      })
      
      const result = await response.json()
      content = result.choices?.[0]?.message?.content
      
    } else if (model.provider === PROVIDERS.GEMINI) {
      const url = `${model.apiUrl}?key=${model.apiKey}`
      response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: processedTemplate
            }]
          }],
          generationConfig: {
            maxOutputTokens: Number(model.maxTokens),
            temperature: Number(model.temperature)
          }
        })
      })
      
      const result = await response.json()
      content = result.candidates?.[0]?.content?.parts?.[0]?.text
    } else if (model.provider === PROVIDERS.OLLAMA) {
      console.log(model.apiUrl)
      response = await fetch(model.apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: model.modelId,
          messages: [
            {
              role: "user",
              content: processedTemplate
            }
          ],
          stream: false,
          options: {
            temperature: Number(model.temperature),
            num_predict: Number(model.maxTokens)
          }
        })
      })
      
      const result = await response.json()
      content = result.message?.content
    }

    if (!response.ok) {
      throw new Error(`请求失败: ${response.status}`)
    }

    if (!content) {
      throw new Error('响应格式错误')
    }
    showToast('数据返回成功')
    
    // 创建新卡片
    const newCard = {
      id: Date.now(),
      content,
      title: '生成的内容',
      height: '200px',
      tags: []
    }
    
    if (currentScene.value) {
      currentScene.value.cards.push(newCard)
    }

    
    // 清理状态
    prompt.insertedContents = []
    prompt.selectedModel = prompt.defaultModel || ''

  } catch (error) {
    console.error('API 请求错误:', error)
    showToast(error.message, 'error')
  }
}

const insertSelectedCards = () => {
  if (!selectedPrompt.value || !canInsertSelected()) return

  let resultTemplate = selectedPrompt.value.template
  const selectedTexts = selectedCards.value.map(id =>
    textCards.value.find(card => card.id === id)?.content
  )

  selectedTexts.forEach(text => {
    resultTemplate = resultTemplate.replace('{{text}}', text)
  })

  textCards.value.push({
    id: Date.now(),
    content: resultTemplate,
    isResult: true
  })

  clearSelection()
}


// 简化的文件导入处理
const importPrompts = async (event) => {
  const files = event.target.files
  if (!files.length) return

  try {
    for (const file of files) {
      let content = await file.text()
      
      // 根据文件类型处理内容
      if (file.name.endsWith('.json')) {
        try {
          const jsonData = JSON.parse(content)
          // 如果是数组，直接添加；如果是单个对象，包装成数组
          const newPrompts = Array.isArray(jsonData) ? jsonData : [jsonData]
          
          newPrompts.forEach(prompt => {
            prompt.id = Date.now() + Math.random()
            prompts.value.push(prompt)
          })
        } catch (e) {
          console.warn('JSON 解析失败，作为普通文本处理')
          // 如果 JSON 解析失败，作为普通文本处理
          prompts.value.push({
            id: Date.now() + Math.random(),
            title: file.name,
            template: content.trim(),
            defaultModel: models.value[0]?.id || ''
          })
        }
      } else {
        // 处理 .txt, .md 等其他文本文件
        prompts.value.push({
          id: Date.now() + Math.random(),
          title: file.name,
          template: content.trim(),
          defaultModel: models.value[0]?.id || ''
        })
      }
    }

    event.target.value = ''
    savePrompts() // 保存到本地存储
    showToast('提示词导入成功')

  } catch (error) {
    console.error('提示词导入错误:', error)
    showToast('提示词导入失败: ' + error.message, 'error')
  }
}

// 添加文件拖放支持
const handleDragOver = (event) => {
  event.preventDefault()
  event.stopPropagation()
}

const handleDrop = async (event) => {
  event.preventDefault()
  event.stopPropagation()
  
  const files = event.dataTransfer.files
  if (files.length > 0) {
    try {
      for (const file of files) {
        let content = await file.text()
        
        if (file.name.endsWith('.json')) {
          try {
            const jsonData = JSON.parse(content)
            content = JSON.stringify(jsonData, null, 2)
          } catch (e) {
            console.warn('JSON 解析失败，作为普通文本处理')
          }
        }

        textCards.value.push({
          id: Date.now() + Math.random(),
          content: content.trim(),
          title: file.name,
          height: '200px'
        })
      }
    } catch (error) {
      console.error('文件导入错误:', error)
      alert('文件导入失败: ' + error.message)
    }
  }
}

const exportToJsonl = () => {
  const jsonl = textCards.value
    .map(card => JSON.stringify({ content: card.content }))
    .join('\n')
  
  const blob = new Blob([jsonl], { type: 'application/x-jsonl' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = 'cards.jsonl'
  a.click()
  URL.revokeObjectURL(url)
}

// 新增的插入提示词相关方法
const insertPromptAtCursor = (card) => {
  currentEditingCard.value = card
  showPromptSelectModal.value = true
}

const insertPromptToCard = (prompt) => {
  if (!currentEditingCard.value) return
  
  const insertCount = getInsertCount(prompt.template)
  if (insertCount === 0) return
  
  // 初始化插入内容数组
  if (!prompt.insertedContents) {
    prompt.insertedContents = []
  }
  
  // 检查是否还能插入更多内容
  if (prompt.insertedContents.length >= insertCount) {
    alert('已达到最大插入数量')
    return
  }
  
  // 添加插入的内容
  prompt.insertedContents.push(currentEditingCard.value.content)
  
  showPromptSelectModal.value = false
  currentEditingCard.value = null
}

const removeInsertedContent = (prompt, index) => {
  prompt.insertedContents.splice(index, 1)
}

const hasInsertedContent = (prompt) => {
  return prompt.insertedContents?.length > 0
}

const truncateText = (text, length = 20) => {
  return text.length > length ? text.slice(0, length) + '...' : text
}

// 计算可插入的提示词
const insertablePrompts = computed(() => {
  return prompts.value.filter(prompt => getInsertCount(prompt.template) > 0)
})

// 模型管理方法
const addModel = () => {
  models.value.push(createDefaultModel())
}

const deleteModel = (id) => {
  models.value = models.value.filter(model => model.id !== id)
  saveModels()
}

// 添加获取模型列表的方法
const fetchModelList = async (model) => {
  try {
    let response
    let modelList = []
    
    if (model.provider === 'stepfun') {
      // 阶跃星辰获取模型列表
      response = await fetch(`${model.apiUrl}/models`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${model.apiKey}`
        }
      })
      
      const result = await response.json()
      if (!response.ok) {
        throw new Error(result.message || `请求失败: ${response.status}`)
      }
      
      // 处理返回的模型列表
      modelList = result.data?.map(m => ({
        id: m.id,
        name: m.name || m.id
      })) || []
      
      console.log('获取到的模型列表:', modelList)
    } else if (model.provider === 'mistral') {
      // Mistral 获取模型列表
      response = await fetch(`${model.apiUrl}/v1/models`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${model.apiKey}`
        }
      })
      
      const result = await response.json()
      if (!response.ok) {
        throw new Error(result.message || `请求失败: ${response.status}`)
      }
      
      // 处理返回的模型列表
      modelList = result.data?.map(m => ({
        id: m.id,
        name: m.id
      })) || []
      
      // 过滤掉 moderation 模型
      modelList = modelList.filter(m => !m.id.includes('moderation'))
      
      console.log('获取到的 Mistral 模型列表:', modelList)
    } else if (model.provider === 'openai') {
      // OpenAI获取模型列表保持不变
      // ... existing code ...
    }
    
    return modelList
  } catch (error) {
    console.error('获取模型列表失败:', error)
    showToast('获取模型列表失败主人~: ' + error.message, 'error')
    return []
  }
}

// 修改保存模型的方法
const saveModels = async () => {
  // 验证所有模型的基础 URL
  const invalidModels = models.value.filter(model => !validateApiUrl(model.apiUrl))
  if (invalidModels.length > 0) {
    alert('请检查 API 地址格式，确保以 https:// 开头')
    return
  }
  
  try {
    // 获取每个模型的可用模型列表
    for (const model of models.value) {
      if (model.provider === 'stepfun' || model.provider === 'openai') {
        const modelList = await fetchModelList(model)
        if (modelList.length > 0) {
          // 如果当前选择的模型不在列表中，使用第一个可用模型
          const isValidModel = modelList.some(m => m.id === model.modelId)
          if (!isValidModel) {
            model.modelId = modelList[0].id
          }
        }
      }
    }
    
    localStorage.setItem('aiModels', JSON.stringify(models.value))
    showToast('保存成功主人~')
  } catch (error) {
    console.error('保存失败:', error)
    showToast('保存失败主人~: ' + error.message, 'error')
  }
}

// 修改创建默认模型的方法
const createDefaultModel = () => ({
  id: Date.now(),
  name: '',
  apiUrl: 'https://platform.stepfun.com/v1',  // 设置默认API地址
  modelId: '',
  apiKey: '',
  maxTokens: 512,
  temperature: 0.7,
  provider: 'stepfun',
  availableModels: []
})

// 添加获取模型列表的按钮事件处理
const refreshModelList = async (model) => {
  try {
    const modelList = await fetchModelList(model)
    model.availableModels = modelList
    showToast('获取模型列表成功主人~')
  } catch (error) {
    console.error('获取模型列表失败:', error)
    showToast('获取模型列表失败主人~: ' + error.message, 'error')
  }
}

// 添加 API URL 验证
const validateApiUrl = (url) => {
  return url.startsWith('https://') || url.startsWith('http://')
}

// 修改默认的 Gemini 模型配置
const defaultGeminiModel = {
  id: 'gemini',
  name: 'Gemini',
  provider: PROVIDERS.GEMINI,
  apiUrl: '', // 用户自己填写 API 地址
  modelId: '', // 用户自己填写模型 ID
  apiKey: '',
  maxTokens: 2048,
  temperature: 0.7
}

// 添加默认的 Ollama 模型配置
const defaultOllamaModel = {
  id: 'ollama',
  name: 'Ollama',
  provider: PROVIDERS.OLLAMA,
  apiUrl: 'http://localhost:11434/api/chat',  // Ollama 默认地址
  modelId: 'llama2',  // 默认模型
  apiKey: '',  // Ollama 本地服务不需要 API key
  maxTokens: 512,
  temperature: 0.7
}

// 修改默认的 Mistral 模型配置
const defaultMistralModel = {
  id: 'mistral',
  name: 'Mistral AI',
  provider: 'mistral',
  apiUrl: 'https://api.mistral.ai',
  apiKey: '',
  modelId: '',
  maxTokens: 512,
  temperature: 0.7,
  availableModels: []
}

// 在 onMounted 中初始化模型
onMounted(() => {
  // 加载保存的模型
  const savedModels = localStorage.getItem('aiModels')
  if (savedModels) {
    models.value = JSON.parse(savedModels)
  } else {
    // 如果没有保存的模型，添加所有默认模型
    models.value = [
      createDefaultModel(), 
      defaultGeminiModel, 
      defaultOllamaModel,
      defaultMistralModel
    ]
  }
  
  // 确保所有提示词都有必要的属性
  prompts.value = prompts.value.map(prompt => ({
    ...prompt,
    insertedContents: prompt.insertedContents || [],
    selectedModel: prompt.selectedModel || prompt.defaultModel || ''
  }))

  // 初始化场景
  const savedScenes = localStorage.getItem('scenes')
  if (savedScenes) {
    scenes.value = JSON.parse(savedScenes)
    if (scenes.value.length > 0) {
      currentScene.value = scenes.value[0]
    }
  } else {
    // 创建默认场景
    const defaultScene = {
      id: Date.now(),
      name: '默认场景',
      cards: []
    }
    scenes.value = [defaultScene]
    currentScene.value = defaultScene
  }

  // 加载已保存的提示词
  const savedPrompts = localStorage.getItem('prompts')
  if (savedPrompts) {
    prompts.value = JSON.parse(savedPrompts)
  }

  // 在组件挂载时加载标签
  loadTags()
})

// 处理 API 地址输入
const handleApiUrlInput = (event, model) => {
  let url = event.target.value
  // 移除末尾的 /chat/completions（如果有）
  url = url.replace(/\/chat\/completions$/, '')
  // 移除末尾的斜杠（如果有）
  url = url.replace(/\/$/, '')
  model.apiUrl = url
}

// 获取完整的 API 地址
const getFullApiUrl = (baseUrl) => {
  return `${baseUrl}/chat/completions`
}

// 面板宽度调整
const startPanelResize = (e) => {
  isResizing = true
  startX = e.clientX
  startWidth = promptPanelWidth.value

  document.addEventListener('mousemove', handlePanelResize)
  document.addEventListener('mouseup', stopPanelResize)
}

const handlePanelResize = (e) => {
  if (!isResizing) return
  const diff = e.clientX - startX
  promptPanelWidth.value = Math.max(200, Math.min(600, startWidth + diff))
}

const stopPanelResize = () => {
  isResizing = false
  document.removeEventListener('mousemove', handlePanelResize)
  document.removeEventListener('mouseup', stopPanelResize)
}

// 卡片高度调整
const startCardResize = (e, card) => {
  e.stopPropagation()
  const textarea = e.target.parentElement.querySelector('textarea')
  const startY = e.clientY
  const startHeight = textarea.offsetHeight

  const handleMouseMove = (e) => {
    const diff = e.clientY - startY
    const newHeight = Math.max(120, startHeight + diff)
    card.height = `${newHeight}px`
  }

  const handleMouseUp = () => {
    document.removeEventListener('mousemove', handleMouseMove)
    document.removeEventListener('mouseup', handleMouseUp)
  }

  document.addEventListener('mousemove', handleMouseMove)
  document.addEventListener('mouseup', handleMouseUp)
}

// 显示提示词详情
const showPromptDetail = (prompt) => {
  selectedPrompt.value = prompt
  showPromptDetailModal.value = true
}

// 显示卡片详情
const viewCardDetail = (card) => {
  selectedCard.value = card
  showCardDetailModal.value = true
}

// 场景操作方法
const createNewScene = () => {
  const newScene = {
    id: Date.now(),
    name: `场景 ${scenes.value.length + 1}`,
    cards: []
  }
  scenes.value.push(newScene)
  currentScene.value = newScene
  saveScenes()
}

const switchScene = (scene) => {
  currentScene.value = scene
  // 确保引用更新
  const index = scenes.value.findIndex(s => s.id === scene.id)
  if (index !== -1) {
    scenes.value[index] = scene
  }
}

const deleteScene = (sceneId) => {
  if (!confirm('确定要删除这个场景吗？')) return
  
  const index = scenes.value.findIndex(s => s.id === sceneId)
  if (index !== -1) {
    scenes.value.splice(index, 1)
    if (currentScene.value.id === sceneId) {
      currentScene.value = scenes.value[0]
    }
    saveScenes()
  }
}

// 保存场景到本地存储
const saveScenes = () => {
  localStorage.setItem('scenes', JSON.stringify(scenes.value))
}

// 监听场景变化并保存
watch(
  [scenes, currentScene],
  () => {
    // 深度保存场景数据
    localStorage.setItem('scenes', JSON.stringify(scenes.value))
  },
  { deep: true }
)

// 添加场景名称编辑功能
const editSceneName = (scene) => {
  const newName = prompt('请输入新的场景名称:', scene.name)
  if (newName && newName.trim()) {
    scene.name = newName.trim()
    saveScenes() // 保存更改
  }
}

// 保存提示词到本地存储
const savePrompts = () => {
  localStorage.setItem('prompts', JSON.stringify(prompts.value))
}

// 监听提示词变化并保存
watch(() => prompts.value, savePrompts, { deep: true })

// 添加标签相关的方法
const addTag = () => {
  if (newTagName.value.trim()) {
    const tag = {
      id: Date.now(),
      name: newTagName.value.trim(),
      isKeyword: false // 添加关键词标记
    }
    tags.value.push(tag)
    saveTags()
    newTagName.value = ''
  }
}

const deleteTag = (tagId) => {
  tags.value = tags.value.filter(tag => tag.id !== tagId)
  // 同时从所有卡片中移除该标签
  currentScene.value.cards.forEach(card => {
    if (card.tags) {
      card.tags = card.tags.filter(tag => tag !== tagId)
    }
  })
  saveTags()
}

const toggleCardTag = (card, tagId) => {
  if (!card.tags) {
    card.tags = []
  }
  const index = card.tags.indexOf(tagId)
  if (index === -1) {
    card.tags.push(tagId)
  } else {
    card.tags.splice(index, 1)
  }
  saveScenes()
}

const toggleTagFilter = (tagId) => {
  const index = selectedTags.value.indexOf(tagId)
  if (index === -1) {
    selectedTags.value.push(tagId)
  } else {
    selectedTags.value.splice(index, 1)
  }
}

// 保存标签到本地存储
const saveTags = () => {
  localStorage.setItem('tags', JSON.stringify(tags.value))
}

// 修改提示框实现
const showToast = (message, type = 'success') => {
  // 先移除可能存在的旧提示框
  const existingToast = document.querySelector('.toast-notification')
  if (existingToast) {
    document.body.removeChild(existingToast)
  }

  // 创建提示框容器
  const toastContainer = document.createElement('div')
  toastContainer.className = 'toast-notification'
  toastContainer.style.cssText = `
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%) translateY(-100%);
    background: white;
    border-radius: 4px;
    padding: 8px 16px;
    display: flex;
    align-items: center;
    gap: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    opacity: 0;
    transition: all 0.3s ease;
    min-width: 200px;
    justify-content: center;
    border-left: 4px solid ${type === 'success' ? '#10b981' : '#ef4444'};
  `

  // 创建图标
  const icon = document.createElement('i')
  icon.className = type === 'success' ? 'fas fa-check' : 'fas fa-exclamation-circle'
  icon.style.color = type === 'success' ? '#10b981' : '#ef4444'

  // 创建文本
  const text = document.createElement('span')
  text.textContent = message
  text.style.fontSize = '14px'

  // 组装提示框
  toastContainer.appendChild(icon)
  toastContainer.appendChild(text)
  document.body.appendChild(toastContainer)

  // 显示动画
  requestAnimationFrame(() => {
    toastContainer.style.transform = 'translateX(-50%) translateY(0)'
    toastContainer.style.opacity = '1'
  })

  // 2秒后消失
  setTimeout(() => {
    toastContainer.style.transform = 'translateX(-50%) translateY(-100%)'
    toastContainer.style.opacity = '0'
    
    // 动画结束后移除元素
    setTimeout(() => {
      if (toastContainer.parentNode) {
        document.body.removeChild(toastContainer)
      }
    }, 300)
  }, 2000)
}

// 切换标签的关键词状态
const toggleTagKeyword = (tagId) => {
  const tag = tags.value.find(t => t.id === tagId)
  if (tag) {
    tag.isKeyword = !tag.isKeyword
    saveTags()
  }
}

// 加载标签
const loadTags = () => {
  const savedTags = localStorage.getItem('tags')
  if (savedTags) {
    tags.value = JSON.parse(savedTags)
  }
}

// 在 prompts 相关方法中添加删除提示词的方法
const deletePrompt = (promptId) => {
  if (confirm('确定要删除这个提示词吗？')) {
    prompts.value = prompts.value.filter(p => p.id !== promptId)
    // 保存到本地存储
    localStorage.setItem('prompts', JSON.stringify(prompts.value))
  }
}

// 添加视图切换状态
const currentView = ref('main')

// 修改场景加载方法
const loadScenes = () => {
  const savedScenes = localStorage.getItem('scenes')
  if (savedScenes) {
    scenes.value = JSON.parse(savedScenes)
    if (scenes.value.length > 0) {
      currentScene.value = scenes.value[0]
    }
  } else {
    // 创建默认场景
    const defaultScene = {
      id: Date.now(),
      name: '默认场景',
      cards: []
    }
    scenes.value = [defaultScene]
    currentScene.value = defaultScene
    // 立即保存默认场景
    localStorage.setItem('scenes', JSON.stringify(scenes.value))
  }
}

// 修改处理移动卡片的方法
const handleMoveCard = ({ card, sourceSceneId, targetSceneId }) => {
  //console.log('Moving card:', { card, sourceSceneId, targetSceneId }) // 调试日志

  // 找到源场景和目标场景
  const sourceSceneIndex = scenes.value.findIndex(s => s.id === sourceSceneId)
  const targetSceneIndex = scenes.value.findIndex(s => s.id === targetSceneId)
  
  if (sourceSceneIndex === -1 || targetSceneIndex === -1) {
    console.error('Scene not found')
    return
  }
  
  // 创建新的场景数组以保持响应性
  const newScenes = [...scenes.value]
  
  // 从源场景移除卡片
  newScenes[sourceSceneIndex].cards = newScenes[sourceSceneIndex].cards.filter(c => c.id !== card.id)
  
  // 添加到目标场景
  newScenes[targetSceneIndex].cards.push({ ...card })
  
  // 更新场景数组
  scenes.value = newScenes
  
  // 如果当前场景是源场景，更新 currentScene
  if (currentScene.value?.id === sourceSceneId) {
    currentScene.value = newScenes[sourceSceneIndex]
  }
  
  // 保存到本地存储
  localStorage.setItem('scenes', JSON.stringify(scenes.value))
  
  // 显示成功提示
  showToast(`已将卡片移动到「${newScenes[targetSceneIndex].name}」`)
}

// 修改提供的移动到场景方法
provide('moveToScene', (cardData, targetSceneId) => {
  console.log('Moving to scene:', { cardData, targetSceneId }) // 添加调试日志
  const targetScene = scenes.value.find(s => s.id === targetSceneId)
  if (!targetScene) {
    console.error('Target scene not found:', targetSceneId)
    return
  }
  
  const newCard = {
    id: Date.now(),
    ...cardData
  }
  
  targetScene.cards.push(newCard)
  scenes.value = [...scenes.value]
  
  showToast(`已添加到场景「${targetScene.name}」`)
})

// 添加处理添加卡片到场景的方法
const handleAddCardsToScene = ({ sceneId, cards }) => {
  const targetScene = scenes.value.find(scene => scene.id === sceneId)
  if (!targetScene) {
    console.error('Target scene not found:', sceneId)
    return
  }

  // 确保场景有 cards 属性
  if (!targetScene.cards) {
    targetScene.cards = []
  }

  // 添加卡片到目标场景
  targetScene.cards.push(...cards)
  
  // 确保更新响应式
  scenes.value = [...scenes.value]
  
  // 保存到本地存储
  saveScenes()
}

// 添加合并卡片的方法
const handleMergeCards = (cards) => {
  // 合并卡片的逻辑
  console.log('Merging cards:', cards)
  // 这里可以添加合并卡片的逻辑
}

// 修改创建新卡片的逻辑
const createNewCard = () => {
  const newCard = {
    id: Date.now(),
    content: '',
    title: '新建卡片',
    height: '200px',
    tags: [],
    insertedContents: [] // 添加插入内容数组
  }
  
  if (currentScene.value) {
    currentScene.value.cards.push(newCard)
  }
}

// 修改更新卡片的方法
const updateCard = (card) => {
  if (!currentScene.value) return
  
  const index = currentScene.value.cards.findIndex(c => c.id === card.id)
  if (index !== -1) {
    currentScene.value.cards[index] = { ...card }
    saveScenes() // 保存更新
  }
}

// Add new method to prevent text selection during scene drag
const preventTextSelection = (prevent) => {
  document.body.style.userSelect = prevent ? 'none' : ''
  document.body.style.webkitUserSelect = prevent ? 'none' : ''
}

// Watch scene drag state
watch(dragScene, (isDragging) => {
  preventTextSelection(isDragging)
})

// Clean up when component is unmounted
onUnmounted(() => {
  preventTextSelection(false)
})

// 修改处理添加到笔记本的方法
const handleAddToNotepad = (cardData) => {
  //console.log('Handling add to notepad:', cardData)
  // 先切换到笔记本视图
  
  showToast('已添加到记事本')
  currentView.value = 'note'
  // 使用 nextTick 确保视图更新后再设置内容
  nextTick(() => {
    // 设置笔记本初始内容，包含标题和完整信息
    const formattedContent = `# ${cardData.title}\n\n${cardData.content}`
    //console.log('Formatted content for notepad:', formattedContent)
    
    // 重置后设置新值
    notepadInitialContent.value = ''
    setTimeout(() => {
      notepadInitialContent.value = formattedContent
    }, 10)
  })
}

const notepadInitialContent = ref('')

// 修改删除场景的方法
const handleDeleteScene = async (sceneId) => {
  try {
    // 找到要删除的场景索引
    const index = scenes.value.findIndex(s => s.id === sceneId)
    if (index === -1) {
      throw new Error('场景不存在')
    }

    // 如果只剩一个场景，不允许删除
    if (scenes.value.length <= 1) {
      throw new Error('至少需要保留一个场景')
    }

    // 如果要删除的是当前场景，先切换到其他场景
    if (currentScene.value.id === sceneId) {
      // 如果有下一个场景就切换到下一个，否则切换到上一个
      const nextScene = scenes.value[index + 1] || scenes.value[index - 1]
      currentScene.value = nextScene
    }

    // 从数组中移除场景
    scenes.value.splice(index, 1)

    // 保存更改到本地存储
    saveScenes()

    // 显示成功提示
    showToast('场景已删除')
  } catch (error) {
    console.error('删除场景失败:', error)
    showToast(error.message, 'error')
  }
}
</script>根据这个来弄，不要修改别的内容，只是查看这里的插入功能，并且插入只是内容，显示也只能是内容，或者卡片标题

---

_**Assistant**_



---



---

